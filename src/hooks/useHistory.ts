import { useState, useCallback, useMemo } from 'react';

interface UseHistoryOptions<T> {
    initialState: T;
    maxHistory?: number;
}

interface UseHistoryResult<T> {
    state: T;
    set: (newState: T) => void;
    undo: () => void;
    redo: () => void;
    canUndo: boolean;
    canRedo: boolean;
    reset: (newState: T) => void;
    history: T[];
    index: number;
}

export function useHistory<T>({ initialState, maxHistory = 50 }: UseHistoryOptions<T>): UseHistoryResult<T> {
    const [history, setHistory] = useState<T[]>([initialState]);
    const [index, setIndex] = useState(0);

    const state = useMemo(() => history[index], [history, index]);



    // Daha güvenli set implementasyonu (State batching sorunlarından kaçınmak için)
    // Yukarıdaki implementasyon functional update kullanıyor ama index ve history birbirine bağlı.
    // En temizi render cycle'ındaki değerleri kullanmak:

    const setSafe = useCallback((newState: T) => {
        const upToCurrent = history.slice(0, index + 1);
        const nextHistory = [...upToCurrent, newState];

        if (nextHistory.length > maxHistory) {
            nextHistory.shift();
        }

        setHistory(nextHistory);
        setIndex(nextHistory.length - 1);
    }, [history, index, maxHistory]);

    const undo = useCallback(() => {
        setIndex((prev) => Math.max(0, prev - 1));
    }, []);

    const redo = useCallback(() => {
        setIndex((prev) => Math.min(history.length - 1, prev + 1));
    }, [history.length]);

    const reset = useCallback((newState: T) => {
        setHistory([newState]);
        setIndex(0);
    }, []);

    return {
        state,
        set: setSafe,
        undo,
        redo,
        canUndo: index > 0,
        canRedo: index < history.length - 1,
        reset,
        history,
        index,
    };
}
